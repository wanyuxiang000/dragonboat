// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: raft.proto

// Package raftpb contains definition of raft internal structs, states and
// messages that are not visible to typical dragonboat applications. It is
// required when building your customized LogDB and Raft RPC modules. You
// can safely ignore this package when building dragonboat applications.

package raftpb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	io "io"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

type MessageType int32

const (
	LocalTick         MessageType = 0
	Election          MessageType = 1
	LeaderHeartbeat   MessageType = 2
	ConfigChangeEvent MessageType = 3
	NoOP              MessageType = 4
	Ping              MessageType = 5
	Pong              MessageType = 6
	Propose           MessageType = 7
	SnapshotStatus    MessageType = 8
	Unreachable       MessageType = 9
	CheckQuorum       MessageType = 10
	BatchedReadIndex  MessageType = 11
	Replicate         MessageType = 12
	ReplicateResp     MessageType = 13
	RequestVote       MessageType = 14
	RequestVoteResp   MessageType = 15
	InstallSnapshot   MessageType = 16
	Heartbeat         MessageType = 17
	HeartbeatResp     MessageType = 18
	ReadIndex         MessageType = 19
	ReadIndexResp     MessageType = 20
	Quiesce           MessageType = 21
	SnapshotReceived  MessageType = 22
	LeaderTransfer    MessageType = 23
	TimeoutNow        MessageType = 24
	RateLimit         MessageType = 25
)

var MessageType_name = map[int32]string{
	0:  "LocalTick",
	1:  "Election",
	2:  "LeaderHeartbeat",
	3:  "ConfigChangeEvent",
	4:  "NoOP",
	5:  "Ping",
	6:  "Pong",
	7:  "Propose",
	8:  "SnapshotStatus",
	9:  "Unreachable",
	10: "CheckQuorum",
	11: "BatchedReadIndex",
	12: "Replicate",
	13: "ReplicateResp",
	14: "RequestVote",
	15: "RequestVoteResp",
	16: "InstallSnapshot",
	17: "Heartbeat",
	18: "HeartbeatResp",
	19: "ReadIndex",
	20: "ReadIndexResp",
	21: "Quiesce",
	22: "SnapshotReceived",
	23: "LeaderTransfer",
	24: "TimeoutNow",
	25: "RateLimit",
}

var MessageType_value = map[string]int32{
	"LocalTick":         0,
	"Election":          1,
	"LeaderHeartbeat":   2,
	"ConfigChangeEvent": 3,
	"NoOP":              4,
	"Ping":              5,
	"Pong":              6,
	"Propose":           7,
	"SnapshotStatus":    8,
	"Unreachable":       9,
	"CheckQuorum":       10,
	"BatchedReadIndex":  11,
	"Replicate":         12,
	"ReplicateResp":     13,
	"RequestVote":       14,
	"RequestVoteResp":   15,
	"InstallSnapshot":   16,
	"Heartbeat":         17,
	"HeartbeatResp":     18,
	"ReadIndex":         19,
	"ReadIndexResp":     20,
	"Quiesce":           21,
	"SnapshotReceived":  22,
	"LeaderTransfer":    23,
	"TimeoutNow":        24,
	"RateLimit":         25,
}

func (x MessageType) Enum() *MessageType {
	p := new(MessageType)
	*p = x
	return p
}

func (x MessageType) String() string {
	return proto.EnumName(MessageType_name, int32(x))
}

func (x *MessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(MessageType_value, data, "MessageType")
	if err != nil {
		return err
	}
	*x = MessageType(value)
	return nil
}

func (MessageType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{0}
}

type EntryType int32

const (
	ApplicationEntry  EntryType = 0
	ConfigChangeEntry EntryType = 1
)

var EntryType_name = map[int32]string{
	0: "ApplicationEntry",
	1: "ConfigChangeEntry",
}

var EntryType_value = map[string]int32{
	"ApplicationEntry":  0,
	"ConfigChangeEntry": 1,
}

func (x EntryType) Enum() *EntryType {
	p := new(EntryType)
	*p = x
	return p
}

func (x EntryType) String() string {
	return proto.EnumName(EntryType_name, int32(x))
}

func (x *EntryType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(EntryType_value, data, "EntryType")
	if err != nil {
		return err
	}
	*x = EntryType(value)
	return nil
}

func (EntryType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{1}
}

type ConfigChangeType int32

const (
	AddNode     ConfigChangeType = 0
	RemoveNode  ConfigChangeType = 1
	AddObserver ConfigChangeType = 2
)

var ConfigChangeType_name = map[int32]string{
	0: "AddNode",
	1: "RemoveNode",
	2: "AddObserver",
}

var ConfigChangeType_value = map[string]int32{
	"AddNode":     0,
	"RemoveNode":  1,
	"AddObserver": 2,
}

func (x ConfigChangeType) Enum() *ConfigChangeType {
	p := new(ConfigChangeType)
	*p = x
	return p
}

func (x ConfigChangeType) String() string {
	return proto.EnumName(ConfigChangeType_name, int32(x))
}

func (x *ConfigChangeType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ConfigChangeType_value, data, "ConfigChangeType")
	if err != nil {
		return err
	}
	*x = ConfigChangeType(value)
	return nil
}

func (ConfigChangeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{2}
}

type StateMachineType int32

const (
	UnknownStateMachine    StateMachineType = 0
	RegularStateMachine    StateMachineType = 1
	ConcurrentStateMachine StateMachineType = 2
	OnDiskStateMachine     StateMachineType = 3
)

var StateMachineType_name = map[int32]string{
	0: "UnknownStateMachine",
	1: "RegularStateMachine",
	2: "ConcurrentStateMachine",
	3: "OnDiskStateMachine",
}

var StateMachineType_value = map[string]int32{
	"UnknownStateMachine":    0,
	"RegularStateMachine":    1,
	"ConcurrentStateMachine": 2,
	"OnDiskStateMachine":     3,
}

func (x StateMachineType) Enum() *StateMachineType {
	p := new(StateMachineType)
	*p = x
	return p
}

func (x StateMachineType) String() string {
	return proto.EnumName(StateMachineType_name, int32(x))
}

func (x *StateMachineType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StateMachineType_value, data, "StateMachineType")
	if err != nil {
		return err
	}
	*x = StateMachineType(value)
	return nil
}

func (StateMachineType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{3}
}

type CompressionType int32

const (
	NoCompression CompressionType = 0
	Snappy        CompressionType = 1
)

var CompressionType_name = map[int32]string{
	0: "NoCompression",
	1: "Snappy",
}

var CompressionType_value = map[string]int32{
	"NoCompression": 0,
	"Snappy":        1,
}

func (x CompressionType) Enum() *CompressionType {
	p := new(CompressionType)
	*p = x
	return p
}

func (x CompressionType) String() string {
	return proto.EnumName(CompressionType_name, int32(x))
}

func (x *CompressionType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CompressionType_value, data, "CompressionType")
	if err != nil {
		return err
	}
	*x = CompressionType(value)
	return nil
}

func (CompressionType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{4}
}

type ChecksumType int32

const (
	CRC32IEEE ChecksumType = 0
	HIGHWAY   ChecksumType = 1
)

var ChecksumType_name = map[int32]string{
	0: "CRC32IEEE",
	1: "HIGHWAY",
}

var ChecksumType_value = map[string]int32{
	"CRC32IEEE": 0,
	"HIGHWAY":   1,
}

func (x ChecksumType) Enum() *ChecksumType {
	p := new(ChecksumType)
	*p = x
	return p
}

func (x ChecksumType) String() string {
	return proto.EnumName(ChecksumType_name, int32(x))
}

func (x *ChecksumType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ChecksumType_value, data, "ChecksumType")
	if err != nil {
		return err
	}
	*x = ChecksumType(value)
	return nil
}

func (ChecksumType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{5}
}

type Bootstrap struct {
	Addresses map[uint64]string `protobuf:"bytes,1,rep,name=addresses" json:"addresses,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Join      bool              `protobuf:"varint,2,opt,name=join" json:"join"`
	Type      StateMachineType  `protobuf:"varint,3,opt,name=Type,enum=raftpb.StateMachineType" json:"Type"`
}

func (m *Bootstrap) Reset()         { *m = Bootstrap{} }
func (m *Bootstrap) String() string { return proto.CompactTextString(m) }
func (*Bootstrap) ProtoMessage()    {}
func (*Bootstrap) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{0}
}
func (m *Bootstrap) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Bootstrap) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Bootstrap.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Bootstrap) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Bootstrap.Merge(m, src)
}
func (m *Bootstrap) XXX_Size() int {
	return m.Size()
}
func (m *Bootstrap) XXX_DiscardUnknown() {
	xxx_messageInfo_Bootstrap.DiscardUnknown(m)
}

var xxx_messageInfo_Bootstrap proto.InternalMessageInfo

func (m *Bootstrap) GetAddresses() map[uint64]string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *Bootstrap) GetJoin() bool {
	if m != nil {
		return m.Join
	}
	return false
}

func (m *Bootstrap) GetType() StateMachineType {
	if m != nil {
		return m.Type
	}
	return UnknownStateMachine
}

type RaftDataStatus struct {
	Address         string `protobuf:"bytes,1,opt,name=address" json:"address"`
	BinVer          uint32 `protobuf:"varint,2,opt,name=bin_ver,json=binVer" json:"bin_ver"`
	HardHash        uint64 `protobuf:"varint,3,opt,name=hard_hash,json=hardHash" json:"hard_hash"`
	LogdbType       string `protobuf:"bytes,4,opt,name=logdb_type,json=logdbType" json:"logdb_type"`
	Hostname        string `protobuf:"bytes,5,opt,name=hostname" json:"hostname"`
	DeploymentId    uint64 `protobuf:"varint,6,opt,name=deployment_id,json=deploymentId" json:"deployment_id"`
	StepWorkerCount uint64 `protobuf:"varint,7,opt,name=step_worker_count,json=stepWorkerCount" json:"step_worker_count"`
	LogdbShardCount uint64 `protobuf:"varint,8,opt,name=logdb_shard_count,json=logdbShardCount" json:"logdb_shard_count"`
	MaxSessionCount uint64 `protobuf:"varint,9,opt,name=max_session_count,json=maxSessionCount" json:"max_session_count"`
	EntryBatchSize  uint64 `protobuf:"varint,10,opt,name=entry_batch_size,json=entryBatchSize" json:"entry_batch_size"`
}

func (m *RaftDataStatus) Reset()         { *m = RaftDataStatus{} }
func (m *RaftDataStatus) String() string { return proto.CompactTextString(m) }
func (*RaftDataStatus) ProtoMessage()    {}
func (*RaftDataStatus) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{1}
}
func (m *RaftDataStatus) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RaftDataStatus) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RaftDataStatus.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RaftDataStatus) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RaftDataStatus.Merge(m, src)
}
func (m *RaftDataStatus) XXX_Size() int {
	return m.Size()
}
func (m *RaftDataStatus) XXX_DiscardUnknown() {
	xxx_messageInfo_RaftDataStatus.DiscardUnknown(m)
}

var xxx_messageInfo_RaftDataStatus proto.InternalMessageInfo

func (m *RaftDataStatus) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *RaftDataStatus) GetBinVer() uint32 {
	if m != nil {
		return m.BinVer
	}
	return 0
}

func (m *RaftDataStatus) GetHardHash() uint64 {
	if m != nil {
		return m.HardHash
	}
	return 0
}

func (m *RaftDataStatus) GetLogdbType() string {
	if m != nil {
		return m.LogdbType
	}
	return ""
}

func (m *RaftDataStatus) GetHostname() string {
	if m != nil {
		return m.Hostname
	}
	return ""
}

func (m *RaftDataStatus) GetDeploymentId() uint64 {
	if m != nil {
		return m.DeploymentId
	}
	return 0
}

func (m *RaftDataStatus) GetStepWorkerCount() uint64 {
	if m != nil {
		return m.StepWorkerCount
	}
	return 0
}

func (m *RaftDataStatus) GetLogdbShardCount() uint64 {
	if m != nil {
		return m.LogdbShardCount
	}
	return 0
}

func (m *RaftDataStatus) GetMaxSessionCount() uint64 {
	if m != nil {
		return m.MaxSessionCount
	}
	return 0
}

func (m *RaftDataStatus) GetEntryBatchSize() uint64 {
	if m != nil {
		return m.EntryBatchSize
	}
	return 0
}

type State struct {
	Term   uint64 `protobuf:"varint,1,opt,name=term" json:"term"`
	Vote   uint64 `protobuf:"varint,2,opt,name=vote" json:"vote"`
	Commit uint64 `protobuf:"varint,3,opt,name=commit" json:"commit"`
}

func (m *State) Reset()         { *m = State{} }
func (m *State) String() string { return proto.CompactTextString(m) }
func (*State) ProtoMessage()    {}
func (*State) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{2}
}
func (m *State) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *State) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_State.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *State) XXX_Merge(src proto.Message) {
	xxx_messageInfo_State.Merge(m, src)
}
func (m *State) XXX_Size() int {
	return m.Size()
}
func (m *State) XXX_DiscardUnknown() {
	xxx_messageInfo_State.DiscardUnknown(m)
}

var xxx_messageInfo_State proto.InternalMessageInfo

func (m *State) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *State) GetVote() uint64 {
	if m != nil {
		return m.Vote
	}
	return 0
}

func (m *State) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

type Entry struct {
	Term        uint64    `protobuf:"varint,1,opt,name=Term" json:"Term"`
	Index       uint64    `protobuf:"varint,2,opt,name=Index" json:"Index"`
	Type        EntryType `protobuf:"varint,3,opt,name=Type,enum=raftpb.EntryType" json:"Type"`
	Key         uint64    `protobuf:"varint,4,opt,name=Key" json:"Key"`
	ClientID    uint64    `protobuf:"varint,5,opt,name=ClientID" json:"ClientID"`
	SeriesID    uint64    `protobuf:"varint,6,opt,name=SeriesID" json:"SeriesID"`
	RespondedTo uint64    `protobuf:"varint,7,opt,name=RespondedTo" json:"RespondedTo"`
	Cmd         []byte    `protobuf:"bytes,8,opt,name=Cmd" json:"Cmd"`
}

func (m *Entry) Reset()         { *m = Entry{} }
func (m *Entry) String() string { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()    {}
func (*Entry) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{3}
}
func (m *Entry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Entry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Entry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Entry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Entry.Merge(m, src)
}
func (m *Entry) XXX_Size() int {
	return m.Size()
}
func (m *Entry) XXX_DiscardUnknown() {
	xxx_messageInfo_Entry.DiscardUnknown(m)
}

var xxx_messageInfo_Entry proto.InternalMessageInfo

func (m *Entry) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Entry) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Entry) GetType() EntryType {
	if m != nil {
		return m.Type
	}
	return ApplicationEntry
}

func (m *Entry) GetKey() uint64 {
	if m != nil {
		return m.Key
	}
	return 0
}

func (m *Entry) GetClientID() uint64 {
	if m != nil {
		return m.ClientID
	}
	return 0
}

func (m *Entry) GetSeriesID() uint64 {
	if m != nil {
		return m.SeriesID
	}
	return 0
}

func (m *Entry) GetRespondedTo() uint64 {
	if m != nil {
		return m.RespondedTo
	}
	return 0
}

func (m *Entry) GetCmd() []byte {
	if m != nil {
		return m.Cmd
	}
	return nil
}

type EntryBatch struct {
	Entries []Entry `protobuf:"bytes,1,rep,name=entries" json:"entries"`
}

func (m *EntryBatch) Reset()         { *m = EntryBatch{} }
func (m *EntryBatch) String() string { return proto.CompactTextString(m) }
func (*EntryBatch) ProtoMessage()    {}
func (*EntryBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{4}
}
func (m *EntryBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *EntryBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_EntryBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *EntryBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_EntryBatch.Merge(m, src)
}
func (m *EntryBatch) XXX_Size() int {
	return m.Size()
}
func (m *EntryBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_EntryBatch.DiscardUnknown(m)
}

var xxx_messageInfo_EntryBatch proto.InternalMessageInfo

func (m *EntryBatch) GetEntries() []Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

type Membership struct {
	ConfigChangeId uint64            `protobuf:"varint,1,opt,name=config_change_id,json=configChangeId" json:"config_change_id"`
	Addresses      map[uint64]string `protobuf:"bytes,2,rep,name=addresses" json:"addresses,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
	Removed        map[uint64]bool   `protobuf:"bytes,3,rep,name=removed" json:"removed,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"varint,2,opt,name=value"`
	Observers      map[uint64]string `protobuf:"bytes,4,rep,name=observers" json:"observers,omitempty" protobuf_key:"varint,1,opt,name=key" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *Membership) Reset()         { *m = Membership{} }
func (m *Membership) String() string { return proto.CompactTextString(m) }
func (*Membership) ProtoMessage()    {}
func (*Membership) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{5}
}
func (m *Membership) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Membership) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Membership.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Membership) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Membership.Merge(m, src)
}
func (m *Membership) XXX_Size() int {
	return m.Size()
}
func (m *Membership) XXX_DiscardUnknown() {
	xxx_messageInfo_Membership.DiscardUnknown(m)
}

var xxx_messageInfo_Membership proto.InternalMessageInfo

func (m *Membership) GetConfigChangeId() uint64 {
	if m != nil {
		return m.ConfigChangeId
	}
	return 0
}

func (m *Membership) GetAddresses() map[uint64]string {
	if m != nil {
		return m.Addresses
	}
	return nil
}

func (m *Membership) GetRemoved() map[uint64]bool {
	if m != nil {
		return m.Removed
	}
	return nil
}

func (m *Membership) GetObservers() map[uint64]string {
	if m != nil {
		return m.Observers
	}
	return nil
}

// field id 1 was used for optional string filename
type SnapshotFile struct {
	Filepath string `protobuf:"bytes,2,opt,name=filepath" json:"filepath"`
	FileSize uint64 `protobuf:"varint,3,opt,name=file_size,json=fileSize" json:"file_size"`
	FileId   uint64 `protobuf:"varint,4,opt,name=file_id,json=fileId" json:"file_id"`
	Metadata []byte `protobuf:"bytes,5,opt,name=metadata" json:"metadata"`
}

func (m *SnapshotFile) Reset()         { *m = SnapshotFile{} }
func (m *SnapshotFile) String() string { return proto.CompactTextString(m) }
func (*SnapshotFile) ProtoMessage()    {}
func (*SnapshotFile) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{6}
}
func (m *SnapshotFile) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotFile) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotFile.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotFile) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotFile.Merge(m, src)
}
func (m *SnapshotFile) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotFile) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotFile.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotFile proto.InternalMessageInfo

func (m *SnapshotFile) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

func (m *SnapshotFile) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *SnapshotFile) GetFileId() uint64 {
	if m != nil {
		return m.FileId
	}
	return 0
}

func (m *SnapshotFile) GetMetadata() []byte {
	if m != nil {
		return m.Metadata
	}
	return nil
}

// field id 1 was used for optional string filename
type Snapshot struct {
	Filepath    string           `protobuf:"bytes,2,opt,name=filepath" json:"filepath"`
	FileSize    uint64           `protobuf:"varint,3,opt,name=file_size,json=fileSize" json:"file_size"`
	Index       uint64           `protobuf:"varint,4,opt,name=index" json:"index"`
	Term        uint64           `protobuf:"varint,5,opt,name=term" json:"term"`
	Membership  Membership       `protobuf:"bytes,6,opt,name=membership" json:"membership"`
	Files       []*SnapshotFile  `protobuf:"bytes,7,rep,name=files" json:"files,omitempty"`
	Checksum    []byte           `protobuf:"bytes,8,opt,name=checksum" json:"checksum"`
	Dummy       bool             `protobuf:"varint,9,opt,name=dummy" json:"dummy"`
	ClusterId   uint64           `protobuf:"varint,10,opt,name=cluster_id,json=clusterId" json:"cluster_id"`
	Type        StateMachineType `protobuf:"varint,11,opt,name=type,enum=raftpb.StateMachineType" json:"type"`
	Imported    bool             `protobuf:"varint,12,opt,name=imported" json:"imported"`
	OnDiskIndex uint64           `protobuf:"varint,13,opt,name=on_disk_index,json=onDiskIndex" json:"on_disk_index"`
}

func (m *Snapshot) Reset()         { *m = Snapshot{} }
func (m *Snapshot) String() string { return proto.CompactTextString(m) }
func (*Snapshot) ProtoMessage()    {}
func (*Snapshot) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{7}
}
func (m *Snapshot) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Snapshot) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Snapshot.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Snapshot) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Snapshot.Merge(m, src)
}
func (m *Snapshot) XXX_Size() int {
	return m.Size()
}
func (m *Snapshot) XXX_DiscardUnknown() {
	xxx_messageInfo_Snapshot.DiscardUnknown(m)
}

var xxx_messageInfo_Snapshot proto.InternalMessageInfo

func (m *Snapshot) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

func (m *Snapshot) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *Snapshot) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *Snapshot) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Snapshot) GetMembership() Membership {
	if m != nil {
		return m.Membership
	}
	return Membership{}
}

func (m *Snapshot) GetFiles() []*SnapshotFile {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *Snapshot) GetChecksum() []byte {
	if m != nil {
		return m.Checksum
	}
	return nil
}

func (m *Snapshot) GetDummy() bool {
	if m != nil {
		return m.Dummy
	}
	return false
}

func (m *Snapshot) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *Snapshot) GetType() StateMachineType {
	if m != nil {
		return m.Type
	}
	return UnknownStateMachine
}

func (m *Snapshot) GetImported() bool {
	if m != nil {
		return m.Imported
	}
	return false
}

func (m *Snapshot) GetOnDiskIndex() uint64 {
	if m != nil {
		return m.OnDiskIndex
	}
	return 0
}

type Message struct {
	Type      MessageType `protobuf:"varint,1,opt,name=type,enum=raftpb.MessageType" json:"type"`
	To        uint64      `protobuf:"varint,2,opt,name=to" json:"to"`
	From      uint64      `protobuf:"varint,3,opt,name=from" json:"from"`
	ClusterId uint64      `protobuf:"varint,4,opt,name=cluster_id,json=clusterId" json:"cluster_id"`
	Term      uint64      `protobuf:"varint,5,opt,name=term" json:"term"`
	LogTerm   uint64      `protobuf:"varint,6,opt,name=log_term,json=logTerm" json:"log_term"`
	LogIndex  uint64      `protobuf:"varint,7,opt,name=log_index,json=logIndex" json:"log_index"`
	Commit    uint64      `protobuf:"varint,8,opt,name=commit" json:"commit"`
	Reject    bool        `protobuf:"varint,9,opt,name=reject" json:"reject"`
	Hint      uint64      `protobuf:"varint,10,opt,name=hint" json:"hint"`
	Entries   []Entry     `protobuf:"bytes,11,rep,name=entries" json:"entries"`
	Snapshot  Snapshot    `protobuf:"bytes,12,opt,name=snapshot" json:"snapshot"`
	HintHigh  uint64      `protobuf:"varint,13,opt,name=hint_high,json=hintHigh" json:"hint_high"`
}

func (m *Message) Reset()         { *m = Message{} }
func (m *Message) String() string { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()    {}
func (*Message) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{8}
}
func (m *Message) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Message) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Message.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Message) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Message.Merge(m, src)
}
func (m *Message) XXX_Size() int {
	return m.Size()
}
func (m *Message) XXX_DiscardUnknown() {
	xxx_messageInfo_Message.DiscardUnknown(m)
}

var xxx_messageInfo_Message proto.InternalMessageInfo

func (m *Message) GetType() MessageType {
	if m != nil {
		return m.Type
	}
	return LocalTick
}

func (m *Message) GetTo() uint64 {
	if m != nil {
		return m.To
	}
	return 0
}

func (m *Message) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *Message) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *Message) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *Message) GetLogTerm() uint64 {
	if m != nil {
		return m.LogTerm
	}
	return 0
}

func (m *Message) GetLogIndex() uint64 {
	if m != nil {
		return m.LogIndex
	}
	return 0
}

func (m *Message) GetCommit() uint64 {
	if m != nil {
		return m.Commit
	}
	return 0
}

func (m *Message) GetReject() bool {
	if m != nil {
		return m.Reject
	}
	return false
}

func (m *Message) GetHint() uint64 {
	if m != nil {
		return m.Hint
	}
	return 0
}

func (m *Message) GetEntries() []Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

func (m *Message) GetSnapshot() Snapshot {
	if m != nil {
		return m.Snapshot
	}
	return Snapshot{}
}

func (m *Message) GetHintHigh() uint64 {
	if m != nil {
		return m.HintHigh
	}
	return 0
}

type ConfigChange struct {
	ConfigChangeId uint64           `protobuf:"varint,1,opt,name=config_change_id,json=configChangeId" json:"config_change_id"`
	Type           ConfigChangeType `protobuf:"varint,2,opt,name=Type,enum=raftpb.ConfigChangeType" json:"Type"`
	NodeID         uint64           `protobuf:"varint,3,opt,name=NodeID" json:"NodeID"`
	Address        string           `protobuf:"bytes,4,opt,name=Address" json:"Address"`
	Initialize     bool             `protobuf:"varint,5,opt,name=Initialize" json:"Initialize"`
}

func (m *ConfigChange) Reset()         { *m = ConfigChange{} }
func (m *ConfigChange) String() string { return proto.CompactTextString(m) }
func (*ConfigChange) ProtoMessage()    {}
func (*ConfigChange) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{9}
}
func (m *ConfigChange) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ConfigChange) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ConfigChange.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ConfigChange) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ConfigChange.Merge(m, src)
}
func (m *ConfigChange) XXX_Size() int {
	return m.Size()
}
func (m *ConfigChange) XXX_DiscardUnknown() {
	xxx_messageInfo_ConfigChange.DiscardUnknown(m)
}

var xxx_messageInfo_ConfigChange proto.InternalMessageInfo

func (m *ConfigChange) GetConfigChangeId() uint64 {
	if m != nil {
		return m.ConfigChangeId
	}
	return 0
}

func (m *ConfigChange) GetType() ConfigChangeType {
	if m != nil {
		return m.Type
	}
	return AddNode
}

func (m *ConfigChange) GetNodeID() uint64 {
	if m != nil {
		return m.NodeID
	}
	return 0
}

func (m *ConfigChange) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *ConfigChange) GetInitialize() bool {
	if m != nil {
		return m.Initialize
	}
	return false
}

type SnapshotHeader struct {
	SessionSize     uint64          `protobuf:"varint,1,opt,name=session_size,json=sessionSize" json:"session_size"`
	DataStoreSize   uint64          `protobuf:"varint,2,opt,name=data_store_size,json=dataStoreSize" json:"data_store_size"`
	UnreliableTime  uint64          `protobuf:"varint,3,opt,name=unreliable_time,json=unreliableTime" json:"unreliable_time"`
	GitVersion      string          `protobuf:"bytes,4,opt,name=git_version,json=gitVersion" json:"git_version"`
	HeaderChecksum  []byte          `protobuf:"bytes,5,opt,name=header_checksum,json=headerChecksum" json:"header_checksum"`
	PayloadChecksum []byte          `protobuf:"bytes,6,opt,name=payload_checksum,json=payloadChecksum" json:"payload_checksum"`
	ChecksumType    ChecksumType    `protobuf:"varint,7,opt,name=checksum_type,json=checksumType,enum=raftpb.ChecksumType" json:"checksum_type"`
	Version         uint64          `protobuf:"varint,8,opt,name=version" json:"version"`
	CompressionType CompressionType `protobuf:"varint,9,opt,name=compression_type,json=compressionType,enum=raftpb.CompressionType" json:"compression_type"`
}

func (m *SnapshotHeader) Reset()         { *m = SnapshotHeader{} }
func (m *SnapshotHeader) String() string { return proto.CompactTextString(m) }
func (*SnapshotHeader) ProtoMessage()    {}
func (*SnapshotHeader) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{10}
}
func (m *SnapshotHeader) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotHeader) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotHeader.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotHeader) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotHeader.Merge(m, src)
}
func (m *SnapshotHeader) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotHeader) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotHeader.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotHeader proto.InternalMessageInfo

func (m *SnapshotHeader) GetSessionSize() uint64 {
	if m != nil {
		return m.SessionSize
	}
	return 0
}

func (m *SnapshotHeader) GetDataStoreSize() uint64 {
	if m != nil {
		return m.DataStoreSize
	}
	return 0
}

func (m *SnapshotHeader) GetUnreliableTime() uint64 {
	if m != nil {
		return m.UnreliableTime
	}
	return 0
}

func (m *SnapshotHeader) GetGitVersion() string {
	if m != nil {
		return m.GitVersion
	}
	return ""
}

func (m *SnapshotHeader) GetHeaderChecksum() []byte {
	if m != nil {
		return m.HeaderChecksum
	}
	return nil
}

func (m *SnapshotHeader) GetPayloadChecksum() []byte {
	if m != nil {
		return m.PayloadChecksum
	}
	return nil
}

func (m *SnapshotHeader) GetChecksumType() ChecksumType {
	if m != nil {
		return m.ChecksumType
	}
	return CRC32IEEE
}

func (m *SnapshotHeader) GetVersion() uint64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *SnapshotHeader) GetCompressionType() CompressionType {
	if m != nil {
		return m.CompressionType
	}
	return NoCompression
}

// dummy message used by grpc
type Response struct {
}

func (m *Response) Reset()         { *m = Response{} }
func (m *Response) String() string { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()    {}
func (*Response) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{11}
}
func (m *Response) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Response) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Response.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Response) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Response.Merge(m, src)
}
func (m *Response) XXX_Size() int {
	return m.Size()
}
func (m *Response) XXX_DiscardUnknown() {
	xxx_messageInfo_Response.DiscardUnknown(m)
}

var xxx_messageInfo_Response proto.InternalMessageInfo

type MessageBatch struct {
	Requests      []Message `protobuf:"bytes,1,rep,name=requests" json:"requests"`
	DeploymentId  uint64    `protobuf:"varint,2,opt,name=deployment_id,json=deploymentId" json:"deployment_id"`
	SourceAddress string    `protobuf:"bytes,3,opt,name=source_address,json=sourceAddress" json:"source_address"`
	BinVer        uint32    `protobuf:"varint,4,opt,name=bin_ver,json=binVer" json:"bin_ver"`
}

func (m *MessageBatch) Reset()         { *m = MessageBatch{} }
func (m *MessageBatch) String() string { return proto.CompactTextString(m) }
func (*MessageBatch) ProtoMessage()    {}
func (*MessageBatch) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{12}
}
func (m *MessageBatch) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MessageBatch) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MessageBatch.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MessageBatch) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MessageBatch.Merge(m, src)
}
func (m *MessageBatch) XXX_Size() int {
	return m.Size()
}
func (m *MessageBatch) XXX_DiscardUnknown() {
	xxx_messageInfo_MessageBatch.DiscardUnknown(m)
}

var xxx_messageInfo_MessageBatch proto.InternalMessageInfo

func (m *MessageBatch) GetRequests() []Message {
	if m != nil {
		return m.Requests
	}
	return nil
}

func (m *MessageBatch) GetDeploymentId() uint64 {
	if m != nil {
		return m.DeploymentId
	}
	return 0
}

func (m *MessageBatch) GetSourceAddress() string {
	if m != nil {
		return m.SourceAddress
	}
	return ""
}

func (m *MessageBatch) GetBinVer() uint32 {
	if m != nil {
		return m.BinVer
	}
	return 0
}

// field id 11 was used for optional string filename
type SnapshotChunk struct {
	ClusterId      uint64       `protobuf:"varint,1,opt,name=cluster_id,json=clusterId" json:"cluster_id"`
	NodeId         uint64       `protobuf:"varint,2,opt,name=node_id,json=nodeId" json:"node_id"`
	From           uint64       `protobuf:"varint,3,opt,name=from" json:"from"`
	ChunkId        uint64       `protobuf:"varint,4,opt,name=chunk_id,json=chunkId" json:"chunk_id"`
	ChunkSize      uint64       `protobuf:"varint,5,opt,name=chunk_size,json=chunkSize" json:"chunk_size"`
	ChunkCount     uint64       `protobuf:"varint,6,opt,name=chunk_count,json=chunkCount" json:"chunk_count"`
	Data           []byte       `protobuf:"bytes,7,opt,name=data" json:"data"`
	Index          uint64       `protobuf:"varint,8,opt,name=index" json:"index"`
	Term           uint64       `protobuf:"varint,9,opt,name=term" json:"term"`
	Membership     Membership   `protobuf:"bytes,10,opt,name=membership" json:"membership"`
	Filepath       string       `protobuf:"bytes,12,opt,name=filepath" json:"filepath"`
	FileSize       uint64       `protobuf:"varint,13,opt,name=file_size,json=fileSize" json:"file_size"`
	DeploymentId   uint64       `protobuf:"varint,14,opt,name=deployment_id,json=deploymentId" json:"deployment_id"`
	FileChunkId    uint64       `protobuf:"varint,15,opt,name=file_chunk_id,json=fileChunkId" json:"file_chunk_id"`
	FileChunkCount uint64       `protobuf:"varint,16,opt,name=file_chunk_count,json=fileChunkCount" json:"file_chunk_count"`
	HasFileInfo    bool         `protobuf:"varint,17,opt,name=has_file_info,json=hasFileInfo" json:"has_file_info"`
	FileInfo       SnapshotFile `protobuf:"bytes,18,opt,name=file_info,json=fileInfo" json:"file_info"`
	BinVer         uint32       `protobuf:"varint,19,opt,name=bin_ver,json=binVer" json:"bin_ver"`
	OnDiskIndex    uint64       `protobuf:"varint,20,opt,name=on_disk_index,json=onDiskIndex" json:"on_disk_index"`
}

func (m *SnapshotChunk) Reset()         { *m = SnapshotChunk{} }
func (m *SnapshotChunk) String() string { return proto.CompactTextString(m) }
func (*SnapshotChunk) ProtoMessage()    {}
func (*SnapshotChunk) Descriptor() ([]byte, []int) {
	return fileDescriptor_b042552c306ae59b, []int{13}
}
func (m *SnapshotChunk) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SnapshotChunk) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SnapshotChunk.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SnapshotChunk) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SnapshotChunk.Merge(m, src)
}
func (m *SnapshotChunk) XXX_Size() int {
	return m.Size()
}
func (m *SnapshotChunk) XXX_DiscardUnknown() {
	xxx_messageInfo_SnapshotChunk.DiscardUnknown(m)
}

var xxx_messageInfo_SnapshotChunk proto.InternalMessageInfo

func (m *SnapshotChunk) GetClusterId() uint64 {
	if m != nil {
		return m.ClusterId
	}
	return 0
}

func (m *SnapshotChunk) GetNodeId() uint64 {
	if m != nil {
		return m.NodeId
	}
	return 0
}

func (m *SnapshotChunk) GetFrom() uint64 {
	if m != nil {
		return m.From
	}
	return 0
}

func (m *SnapshotChunk) GetChunkId() uint64 {
	if m != nil {
		return m.ChunkId
	}
	return 0
}

func (m *SnapshotChunk) GetChunkSize() uint64 {
	if m != nil {
		return m.ChunkSize
	}
	return 0
}

func (m *SnapshotChunk) GetChunkCount() uint64 {
	if m != nil {
		return m.ChunkCount
	}
	return 0
}

func (m *SnapshotChunk) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *SnapshotChunk) GetIndex() uint64 {
	if m != nil {
		return m.Index
	}
	return 0
}

func (m *SnapshotChunk) GetTerm() uint64 {
	if m != nil {
		return m.Term
	}
	return 0
}

func (m *SnapshotChunk) GetMembership() Membership {
	if m != nil {
		return m.Membership
	}
	return Membership{}
}

func (m *SnapshotChunk) GetFilepath() string {
	if m != nil {
		return m.Filepath
	}
	return ""
}

func (m *SnapshotChunk) GetFileSize() uint64 {
	if m != nil {
		return m.FileSize
	}
	return 0
}

func (m *SnapshotChunk) GetDeploymentId() uint64 {
	if m != nil {
		return m.DeploymentId
	}
	return 0
}

func (m *SnapshotChunk) GetFileChunkId() uint64 {
	if m != nil {
		return m.FileChunkId
	}
	return 0
}

func (m *SnapshotChunk) GetFileChunkCount() uint64 {
	if m != nil {
		return m.FileChunkCount
	}
	return 0
}

func (m *SnapshotChunk) GetHasFileInfo() bool {
	if m != nil {
		return m.HasFileInfo
	}
	return false
}

func (m *SnapshotChunk) GetFileInfo() SnapshotFile {
	if m != nil {
		return m.FileInfo
	}
	return SnapshotFile{}
}

func (m *SnapshotChunk) GetBinVer() uint32 {
	if m != nil {
		return m.BinVer
	}
	return 0
}

func (m *SnapshotChunk) GetOnDiskIndex() uint64 {
	if m != nil {
		return m.OnDiskIndex
	}
	return 0
}

func init() {
	proto.RegisterEnum("raftpb.MessageType", MessageType_name, MessageType_value)
	proto.RegisterEnum("raftpb.EntryType", EntryType_name, EntryType_value)
	proto.RegisterEnum("raftpb.ConfigChangeType", ConfigChangeType_name, ConfigChangeType_value)
	proto.RegisterEnum("raftpb.StateMachineType", StateMachineType_name, StateMachineType_value)
	proto.RegisterEnum("raftpb.CompressionType", CompressionType_name, CompressionType_value)
	proto.RegisterEnum("raftpb.ChecksumType", ChecksumType_name, ChecksumType_value)
	proto.RegisterType((*Bootstrap)(nil), "raftpb.Bootstrap")
	proto.RegisterMapType((map[uint64]string)(nil), "raftpb.Bootstrap.AddressesEntry")
	proto.RegisterType((*RaftDataStatus)(nil), "raftpb.RaftDataStatus")
	proto.RegisterType((*State)(nil), "raftpb.State")
	proto.RegisterType((*Entry)(nil), "raftpb.Entry")
	proto.RegisterType((*EntryBatch)(nil), "raftpb.EntryBatch")
	proto.RegisterType((*Membership)(nil), "raftpb.Membership")
	proto.RegisterMapType((map[uint64]string)(nil), "raftpb.Membership.AddressesEntry")
	proto.RegisterMapType((map[uint64]string)(nil), "raftpb.Membership.ObserversEntry")
	proto.RegisterMapType((map[uint64]bool)(nil), "raftpb.Membership.RemovedEntry")
	proto.RegisterType((*SnapshotFile)(nil), "raftpb.SnapshotFile")
	proto.RegisterType((*Snapshot)(nil), "raftpb.Snapshot")
	proto.RegisterType((*Message)(nil), "raftpb.Message")
	proto.RegisterType((*ConfigChange)(nil), "raftpb.ConfigChange")
	proto.RegisterType((*SnapshotHeader)(nil), "raftpb.SnapshotHeader")
	proto.RegisterType((*Response)(nil), "raftpb.Response")
	proto.RegisterType((*MessageBatch)(nil), "raftpb.MessageBatch")
	proto.RegisterType((*SnapshotChunk)(nil), "raftpb.SnapshotChunk")
}

func init() { proto.RegisterFile("raft.proto", fileDescriptor_b042552c306ae59b) }

var fileDescriptor_b042552c306ae59b = []byte{
	// 1990 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x58, 0xcd, 0x72, 0x1b, 0xc7,
	0xf1, 0xc7, 0xe2, 0x1b, 0x8d, 0xaf, 0xe5, 0x48, 0x96, 0xf0, 0x67, 0xc9, 0x14, 0x85, 0x7f, 0x9c,
	0x30, 0x74, 0x44, 0x39, 0xcc, 0x21, 0x4a, 0x52, 0x15, 0x87, 0x82, 0xe8, 0x10, 0x65, 0x7d, 0x19,
	0xa4, 0xe5, 0xf2, 0x09, 0x35, 0xd8, 0x1d, 0x62, 0xc7, 0xc4, 0xee, 0x20, 0x3b, 0x03, 0x4a, 0xf4,
	0x03, 0xe4, 0x9c, 0x43, 0x9e, 0x22, 0x4f, 0x90, 0x07, 0x48, 0x55, 0x74, 0x4a, 0xe9, 0x92, 0x54,
	0x2a, 0x87, 0x54, 0x22, 0xbd, 0x48, 0xaa, 0x67, 0x76, 0x17, 0xb3, 0x00, 0x19, 0xd9, 0x29, 0xdf,
	0xb0, 0xbf, 0xee, 0x9e, 0xee, 0xe9, 0xee, 0xfd, 0x75, 0x2f, 0x00, 0x62, 0x7a, 0xaa, 0xf6, 0xe6,
	0xb1, 0x50, 0x82, 0x54, 0xf1, 0xf7, 0x7c, 0xb2, 0x79, 0x77, 0xca, 0x55, 0xb0, 0x98, 0xec, 0x79,
	0x22, 0xbc, 0x37, 0x15, 0x53, 0x71, 0x4f, 0x8b, 0x27, 0x8b, 0x53, 0xfd, 0xa4, 0x1f, 0xf4, 0x2f,
	0x63, 0xd6, 0x7f, 0xeb, 0x40, 0xe3, 0x81, 0x10, 0x4a, 0xaa, 0x98, 0xce, 0xc9, 0x2f, 0xa1, 0x41,
	0x7d, 0x3f, 0x66, 0x52, 0x32, 0xd9, 0x73, 0xb6, 0x4b, 0x3b, 0xcd, 0xfd, 0xed, 0x3d, 0x73, 0xf0,
	0x5e, 0xa6, 0xb5, 0x77, 0x90, 0xaa, 0x1c, 0x46, 0x2a, 0xbe, 0x18, 0x2d, 0x4d, 0x48, 0x0f, 0xca,
	0x5f, 0x09, 0x1e, 0xf5, 0x8a, 0xdb, 0xce, 0x4e, 0xfd, 0x41, 0xf9, 0xd5, 0x3f, 0x6f, 0x17, 0x46,
	0x1a, 0x21, 0xfb, 0x50, 0x3e, 0xb9, 0x98, 0xb3, 0x5e, 0x69, 0xdb, 0xd9, 0xe9, 0xec, 0xf7, 0xd2,
	0x43, 0x8f, 0x15, 0x55, 0xec, 0x31, 0xf5, 0x02, 0x1e, 0x31, 0x94, 0xa7, 0x36, 0xf8, 0x7b, 0xf3,
	0x08, 0x3a, 0x79, 0x57, 0xe4, 0x06, 0x94, 0xce, 0xd8, 0x45, 0xcf, 0xd9, 0x76, 0x76, 0xca, 0x89,
	0x2a, 0x02, 0x64, 0x13, 0x2a, 0xe7, 0x74, 0xb6, 0x60, 0xda, 0x71, 0x23, 0x91, 0x18, 0xe8, 0xe7,
	0xc5, 0xfb, 0x4e, 0xff, 0x0f, 0x25, 0xe8, 0x8c, 0xe8, 0xa9, 0x7a, 0x48, 0x15, 0x45, 0x97, 0x0b,
	0x49, 0xb6, 0xa0, 0x96, 0xc4, 0xad, 0x8f, 0x4b, 0x8d, 0x52, 0x90, 0xbc, 0x0f, 0xb5, 0x09, 0x8f,
	0xc6, 0xe7, 0x2c, 0xd6, 0x87, 0xb6, 0x13, 0x79, 0x75, 0xc2, 0xa3, 0xe7, 0x2c, 0x26, 0x77, 0xa0,
	0x11, 0xd0, 0xd8, 0x1f, 0x07, 0x54, 0x06, 0xfa, 0x52, 0x69, 0x3c, 0x75, 0x84, 0x8f, 0xa8, 0x0c,
	0xc8, 0xff, 0x03, 0xcc, 0xc4, 0xd4, 0x9f, 0x8c, 0x15, 0x5e, 0xbc, 0x6c, 0x39, 0x69, 0x68, 0x1c,
	0xef, 0x48, 0xb6, 0xa1, 0x1e, 0x08, 0xa9, 0x22, 0x1a, 0xb2, 0x5e, 0xc5, 0x52, 0xc9, 0x50, 0xf2,
	0x43, 0x68, 0xfb, 0x6c, 0x3e, 0x13, 0x17, 0x21, 0x8b, 0xd4, 0x98, 0xfb, 0xbd, 0xaa, 0xe5, 0xad,
	0xb5, 0x14, 0x0d, 0x7d, 0xf2, 0x11, 0x6c, 0x48, 0xc5, 0xe6, 0xe3, 0x17, 0x22, 0x3e, 0x63, 0xf1,
	0xd8, 0x13, 0x8b, 0x48, 0xf5, 0x6a, 0x96, 0x7a, 0x17, 0xc5, 0x5f, 0x68, 0xe9, 0x00, 0x85, 0x68,
	0x61, 0x62, 0x94, 0xfa, 0x36, 0xc6, 0xa2, 0x6e, 0x5b, 0x68, 0xf1, 0x31, 0x4a, 0x33, 0x8b, 0x90,
	0xbe, 0x1c, 0x4b, 0x26, 0x25, 0x17, 0x51, 0x62, 0xd1, 0xb0, 0x2d, 0x42, 0xfa, 0xf2, 0xd8, 0x48,
	0x8d, 0xc5, 0x1e, 0xb8, 0x0c, 0xab, 0x37, 0x9e, 0x50, 0xe5, 0x05, 0x63, 0xc9, 0xbf, 0x66, 0x3d,
	0xb0, 0x0c, 0x3a, 0x5a, 0xfa, 0x00, 0x85, 0xc7, 0xfc, 0x6b, 0xd6, 0xff, 0x12, 0x2a, 0xba, 0x2d,
	0xb0, 0x9b, 0x14, 0x8b, 0xc3, 0x5c, 0xb9, 0x35, 0x82, 0x92, 0x73, 0xa1, 0x4c, 0xb9, 0x33, 0x09,
	0x22, 0xe4, 0x16, 0x54, 0x3d, 0x11, 0x86, 0x5c, 0xe5, 0x8a, 0x92, 0x60, 0xfd, 0xdf, 0x16, 0xa1,
	0x62, 0x3a, 0xa9, 0x07, 0xe5, 0x93, 0xb5, 0xb3, 0x11, 0xc1, 0x5e, 0x1a, 0x46, 0x3e, 0x7b, 0x99,
	0x3b, 0xdc, 0x40, 0xe4, 0xc3, 0x5c, 0x17, 0x6f, 0xa4, 0x5d, 0xac, 0x8f, 0x5c, 0x6d, 0x5f, 0x6c,
	0xd6, 0x4f, 0xd9, 0x85, 0x2e, 0x7c, 0xd6, 0xac, 0x9f, 0xb2, 0x0b, 0x2c, 0xf9, 0x60, 0xc6, 0xb1,
	0x62, 0x0f, 0x75, 0xc9, 0xb3, 0xce, 0x49, 0x51, 0xd4, 0x38, 0x66, 0x31, 0x67, 0x72, 0xf8, 0x30,
	0x57, 0xed, 0x0c, 0x25, 0xdf, 0x87, 0xe6, 0x88, 0xc9, 0xb9, 0x88, 0x7c, 0xe6, 0x9f, 0x88, 0x5c,
	0x8d, 0x6d, 0x01, 0xc6, 0x30, 0x08, 0x7d, 0x5d, 0xd1, 0x56, 0x1a, 0xc3, 0x20, 0xf4, 0xfb, 0xbf,
	0x00, 0x38, 0xcc, 0xb2, 0x4e, 0xee, 0x42, 0x0d, 0x6b, 0xc0, 0xb3, 0x97, 0xbe, 0x9d, 0xbb, 0x59,
	0xfa, 0x6a, 0x24, 0x3a, 0xfd, 0xbf, 0x96, 0x00, 0x1e, 0xb3, 0x70, 0xc2, 0x62, 0x19, 0xf0, 0x39,
	0xd6, 0xd7, 0x13, 0xd1, 0x29, 0x9f, 0x8e, 0xbd, 0x80, 0x46, 0x53, 0x86, 0x3d, 0x6a, 0xa7, 0xb5,
	0x63, 0xa4, 0x03, 0x2d, 0x1c, 0xfa, 0xe4, 0x63, 0x9b, 0x64, 0x8a, 0xda, 0xdf, 0x9d, 0xd4, 0xdf,
	0xf2, 0xd8, 0xff, 0xc2, 0x32, 0x3f, 0x83, 0x5a, 0xcc, 0x42, 0x71, 0xce, 0xfc, 0x5e, 0x49, 0x9b,
	0xdf, 0xbe, 0xc4, 0x7c, 0x64, 0x34, 0x8c, 0x71, 0xaa, 0x8f, 0xbe, 0xc5, 0x44, 0xb2, 0xf8, 0x9c,
	0xc5, 0xb2, 0x57, 0xbe, 0xd2, 0xf7, 0xd3, 0x54, 0x27, 0xf1, 0x9d, 0xd9, 0x7c, 0x77, 0x9c, 0xb4,
	0xf9, 0x09, 0xb4, 0xec, 0x18, 0xbf, 0xd9, 0x39, 0xf5, 0xf5, 0x73, 0x8e, 0xa0, 0x93, 0x0f, 0xf7,
	0x7f, 0x66, 0xc9, 0xdf, 0x3b, 0xd0, 0x3a, 0x8e, 0xe8, 0x5c, 0x06, 0x42, 0x7d, 0xc2, 0x67, 0x9a,
	0x9c, 0x4e, 0xf9, 0x8c, 0xcd, 0xa9, 0x0a, 0x72, 0x36, 0x19, 0x8a, 0x34, 0x88, 0xbf, 0xcd, 0x4b,
	0x9d, 0xa3, 0x41, 0x84, 0xf1, 0x75, 0x46, 0x22, 0xd5, 0x2a, 0xdc, 0xcf, 0xbd, 0x0a, 0x55, 0x04,
	0x87, 0x3e, 0xfa, 0x08, 0x99, 0xa2, 0x3e, 0x55, 0x54, 0xbf, 0x0d, 0x69, 0x9b, 0x66, 0x68, 0xff,
	0x2f, 0x25, 0xa8, 0xa7, 0x61, 0x7d, 0x37, 0x21, 0x6d, 0x42, 0x85, 0xeb, 0x57, 0xdc, 0x0e, 0xc8,
	0x40, 0x19, 0xe9, 0x54, 0xd6, 0x48, 0xe7, 0x3e, 0x40, 0x98, 0xb5, 0x88, 0x7e, 0x2f, 0x9b, 0xfb,
	0x64, 0xbd, 0x79, 0x12, 0x1b, 0x4b, 0x97, 0xec, 0x42, 0x05, 0x7d, 0xcb, 0x5e, 0x4d, 0x77, 0xdc,
	0xf5, 0x6c, 0xfa, 0x59, 0xc9, 0x1e, 0x19, 0x15, 0xbc, 0xa0, 0x17, 0x30, 0xef, 0x4c, 0x2e, 0xc2,
	0xdc, 0x6b, 0x9b, 0xa1, 0x18, 0xbd, 0xbf, 0x08, 0xc3, 0x0b, 0xcd, 0xba, 0x59, 0x43, 0x68, 0x08,
	0x67, 0x8e, 0x37, 0x5b, 0x48, 0xc5, 0x62, 0xcc, 0xb7, 0xcd, 0xb2, 0x8d, 0x04, 0x1f, 0xfa, 0x38,
	0x8b, 0xf5, 0x48, 0x6a, 0x7e, 0xb3, 0x59, 0xac, 0x92, 0x39, 0xc5, 0xc3, 0xb9, 0x88, 0x15, 0xf3,
	0x7b, 0x2d, 0xcb, 0x6f, 0x86, 0x92, 0x1d, 0x68, 0x8b, 0x68, 0xec, 0x73, 0x79, 0x36, 0x36, 0xc9,
	0x6d, 0xdb, 0xa4, 0x24, 0xa2, 0x87, 0x5c, 0x9e, 0x69, 0x16, 0xed, 0xff, 0xb9, 0x04, 0xb5, 0xc7,
	0x4c, 0x4a, 0x3a, 0x65, 0xe4, 0x6e, 0x12, 0x8b, 0xa3, 0x63, 0xb9, 0xb6, 0x4c, 0xa7, 0x16, 0xaf,
	0x85, 0x71, 0x1d, 0x8a, 0x4a, 0xe4, 0x98, 0xb9, 0xa8, 0x04, 0xd6, 0xec, 0x34, 0x16, 0x61, 0xae,
	0xda, 0x1a, 0x59, 0xc9, 0x47, 0xf9, 0xf2, 0x7c, 0x5c, 0x5d, 0xf2, 0xdb, 0x50, 0x9f, 0x89, 0xe9,
	0x58, 0x4b, 0x6d, 0x22, 0xae, 0xcd, 0xc4, 0x54, 0x0f, 0x8b, 0x3b, 0x80, 0xb3, 0x3c, 0xb9, 0xb0,
	0xcd, 0xc2, 0x68, 0x67, 0x66, 0xc6, 0x72, 0x22, 0xd5, 0xd7, 0x27, 0x12, 0x4a, 0x63, 0xf6, 0x15,
	0xf3, 0x54, 0xae, 0x9a, 0x09, 0x86, 0x91, 0x05, 0x3c, 0x52, 0xb9, 0x42, 0x6a, 0xc4, 0xa6, 0xec,
	0xe6, 0xbb, 0x29, 0x9b, 0xec, 0x43, 0x5d, 0x26, 0xcd, 0xa6, 0xcb, 0xd7, 0xdc, 0x77, 0x57, 0x9b,
	0x30, 0x0d, 0x3c, 0xd5, 0xd3, 0x2b, 0x0e, 0x8f, 0xd4, 0x38, 0xe0, 0xd3, 0x20, 0x57, 0xcc, 0x3a,
	0xc2, 0x47, 0x7c, 0x1a, 0xf4, 0xff, 0xe6, 0x40, 0x6b, 0x60, 0xb1, 0xfb, 0xb7, 0x9e, 0x05, 0xe9,
	0x5a, 0x58, 0xcc, 0xb7, 0xa2, 0x7d, 0xe6, 0xda, 0x5c, 0xbd, 0x05, 0xd5, 0x27, 0xc2, 0x67, 0xc3,
	0x87, 0xf9, 0x11, 0x6f, 0x30, 0xdc, 0xeb, 0x12, 0x82, 0xce, 0xad, 0x5c, 0x29, 0x48, 0xbe, 0x07,
	0x30, 0x8c, 0xb8, 0xe2, 0x74, 0x86, 0xfc, 0x50, 0xb1, 0x92, 0x6e, 0xe1, 0xfd, 0x57, 0x25, 0xe8,
	0xa4, 0x89, 0x39, 0x62, 0xd4, 0x67, 0x31, 0xf9, 0x01, 0xb4, 0xd2, 0xa5, 0x47, 0x53, 0x8b, 0x7d,
	0xad, 0x66, 0x22, 0xd1, 0xec, 0xf2, 0x23, 0xe8, 0x22, 0x6f, 0x8d, 0xa5, 0x12, 0x71, 0x42, 0x43,
	0x76, 0xc3, 0xb6, 0x7d, 0xbd, 0x84, 0x8a, 0xd8, 0x70, 0xd1, 0x5d, 0xe8, 0x2e, 0xa2, 0x98, 0xcd,
	0x38, 0x9d, 0xcc, 0xd8, 0x58, 0xf1, 0x30, 0x4f, 0x5a, 0x9d, 0xa5, 0xf0, 0x84, 0x87, 0x8c, 0x7c,
	0x00, 0xcd, 0x29, 0x57, 0xb8, 0x96, 0xa2, 0xbf, 0xdc, 0x15, 0x61, 0xca, 0xd5, 0x73, 0x83, 0xe3,
	0xa9, 0x81, 0x0e, 0x7b, 0x9c, 0x91, 0x89, 0x4d, 0xae, 0x1d, 0x23, 0x1c, 0xa4, 0x94, 0x72, 0x0f,
	0xdc, 0x39, 0xbd, 0x98, 0x09, 0xea, 0x2f, 0xf5, 0xab, 0x96, 0x7e, 0x37, 0x91, 0x66, 0x06, 0x1f,
	0x43, 0x3b, 0x55, 0x34, 0xeb, 0x6d, 0x4d, 0x17, 0x30, 0x63, 0xb6, 0x54, 0xd1, 0x2a, 0x5e, 0xcb,
	0xb3, 0x30, 0x2c, 0x53, 0x7a, 0x07, 0xfb, 0xb5, 0x48, 0x41, 0x72, 0x84, 0x8d, 0x14, 0xce, 0xe3,
	0x24, 0xe3, 0xda, 0x47, 0x43, 0xfb, 0xb8, 0xb9, 0x6c, 0x92, 0x4c, 0x6e, 0xb9, 0xe9, 0x7a, 0x79,
	0xb8, 0x0f, 0x50, 0x37, 0x1b, 0x91, 0x64, 0xfd, 0x3f, 0x3a, 0xd0, 0x4a, 0xa8, 0xc5, 0x6c, 0x3e,
	0x3f, 0x86, 0x7a, 0xcc, 0x7e, 0xb3, 0x60, 0x52, 0xa5, 0xab, 0x4f, 0x77, 0x85, 0x82, 0xd2, 0x9e,
	0x4f, 0xd5, 0xd6, 0xf7, 0xf1, 0xe2, 0x95, 0xfb, 0xf8, 0x87, 0xd0, 0x91, 0x62, 0x11, 0x7b, 0x6c,
	0x9c, 0x7e, 0x6a, 0x94, 0xac, 0x7a, 0xb5, 0x8d, 0xec, 0x60, 0xfd, 0x83, 0xa3, 0xbc, 0xfe, 0xc1,
	0xd1, 0xff, 0x47, 0x05, 0xda, 0x69, 0x47, 0x0e, 0x82, 0x45, 0x74, 0xb6, 0xc2, 0x6d, 0xce, 0xe5,
	0xdc, 0xf6, 0x3e, 0xd4, 0x22, 0xe1, 0xb3, 0xd5, 0x38, 0xab, 0x08, 0x1a, 0xea, 0xbb, 0x82, 0x39,
	0x6f, 0xe3, 0x1c, 0x5a, 0x44, 0x67, 0xab, 0xbc, 0x59, 0xd3, 0xe8, 0xd0, 0xd7, 0xee, 0xb5, 0x82,
	0x4c, 0x5f, 0xa4, 0xa5, 0x7b, 0xc4, 0x75, 0x77, 0x7f, 0x00, 0x4d, 0xa3, 0x64, 0xbe, 0x13, 0x6c,
	0x0e, 0x35, 0xd6, 0xe6, 0x13, 0xa1, 0x07, 0x65, 0xbd, 0x00, 0xd4, 0xac, 0x9e, 0xd3, 0xc8, 0x72,
	0x54, 0xd7, 0xaf, 0x1e, 0xd5, 0x8d, 0x77, 0x8c, 0x6a, 0xf8, 0x16, 0xa3, 0xda, 0xde, 0x2f, 0x5a,
	0xef, 0xde, 0x2f, 0xda, 0x97, 0xee, 0x17, 0x6b, 0x2d, 0xd2, 0xb9, 0xb2, 0x45, 0x76, 0xa0, 0xad,
	0x4f, 0xcb, 0x72, 0xdd, 0xb5, 0x69, 0x05, 0x45, 0x83, 0x24, 0xdf, 0x7b, 0xe0, 0x5a, 0x9a, 0x26,
	0x9f, 0xae, 0xcd, 0x14, 0x99, 0xb2, 0xc9, 0xe9, 0x0e, 0xb4, 0x03, 0x2a, 0xc7, 0x66, 0xf7, 0x8a,
	0x4e, 0x45, 0x6f, 0xc3, 0xe2, 0xba, 0x66, 0x40, 0x25, 0x6e, 0x1d, 0xc3, 0xe8, 0x54, 0x90, 0x9f,
	0x26, 0x37, 0xd2, 0x5a, 0x44, 0x27, 0xeb, 0xd2, 0x15, 0xc5, 0xbe, 0xa7, 0x36, 0xb4, 0x5a, 0xf6,
	0xda, 0x25, 0xdf, 0xc8, 0x6b, 0x1b, 0xc1, 0xf5, 0x2b, 0x36, 0x82, 0xdd, 0x3f, 0x95, 0xa0, 0x69,
	0x8d, 0x7c, 0xd2, 0x86, 0xc6, 0x23, 0xe1, 0xd1, 0xd9, 0x09, 0xf7, 0xce, 0xdc, 0x02, 0x69, 0x41,
	0xfd, 0x70, 0xc6, 0x3c, 0xc5, 0x45, 0xe4, 0x3a, 0xe4, 0x1a, 0x74, 0x1f, 0x69, 0xfa, 0x3a, 0x62,
	0x34, 0x56, 0x13, 0x46, 0x95, 0x5b, 0x24, 0xef, 0xc1, 0x86, 0x3d, 0x34, 0x0e, 0xcf, 0x59, 0xa4,
	0xdc, 0x12, 0xa9, 0x43, 0xf9, 0x89, 0x78, 0xfa, 0xcc, 0x2d, 0xe3, 0xaf, 0x67, 0x3c, 0x9a, 0xba,
	0x15, 0xfd, 0x4b, 0x44, 0x53, 0xb7, 0x4a, 0x9a, 0x50, 0x7b, 0x16, 0x8b, 0xb9, 0x90, 0xcc, 0xad,
	0x11, 0xb2, 0x64, 0x7c, 0xf3, 0x17, 0x81, 0x5b, 0x27, 0x5d, 0x68, 0x7e, 0x1e, 0xc5, 0x8c, 0x7a,
	0x01, 0x12, 0xb0, 0xdb, 0x40, 0x40, 0x53, 0xdb, 0x67, 0x0b, 0x11, 0x2f, 0x42, 0x17, 0xc8, 0x75,
	0x70, 0x35, 0x93, 0x30, 0x7f, 0xc4, 0xa8, 0xaf, 0x6f, 0xe3, 0x36, 0x31, 0xfe, 0x11, 0x9b, 0xcf,
	0xb8, 0x47, 0x15, 0x73, 0x5b, 0x64, 0x03, 0xda, 0xd9, 0x23, 0x72, 0x91, 0xdb, 0xc6, 0x83, 0x46,
	0x86, 0x51, 0x9e, 0x0b, 0xc5, 0xdc, 0x0e, 0xde, 0xca, 0x02, 0xb4, 0x56, 0x17, 0xc1, 0x61, 0x24,
	0x15, 0x9d, 0xcd, 0xd2, 0xd0, 0x5c, 0x17, 0x0f, 0x5f, 0xde, 0x7c, 0x03, 0x0f, 0xcf, 0x1e, 0xb5,
	0x19, 0x31, 0xee, 0xd3, 0x68, 0xae, 0x19, 0xf7, 0xc9, 0xa3, 0xd6, 0xb8, 0x8e, 0x37, 0xff, 0x6c,
	0xc1, 0x99, 0xf4, 0x98, 0xfb, 0x1e, 0xde, 0x21, 0x3d, 0x7e, 0xc4, 0x3c, 0xc6, 0xcf, 0x99, 0xef,
	0xde, 0xc0, 0x7c, 0x98, 0x34, 0x9f, 0xc4, 0x34, 0x92, 0xa7, 0x2c, 0x76, 0x6f, 0x92, 0x0e, 0x00,
	0x4e, 0x21, 0xb1, 0x50, 0x4f, 0xc4, 0x0b, 0xb7, 0xa7, 0x1d, 0x51, 0xc5, 0x1e, 0xf1, 0x90, 0x2b,
	0xf7, 0xff, 0x76, 0xef, 0x43, 0x23, 0xfb, 0x14, 0xc6, 0x53, 0x0f, 0xe6, 0xe6, 0xd2, 0x5c, 0x44,
	0x1a, 0x77, 0x0b, 0x6b, 0x75, 0xd2, 0xb0, 0xb3, 0xfb, 0x2b, 0x70, 0x57, 0x67, 0x3e, 0xc6, 0x78,
	0xe0, 0xfb, 0x38, 0xd6, 0xdd, 0x02, 0x7a, 0x36, 0x5f, 0x4b, 0xfa, 0xd9, 0xc1, 0xfc, 0x1d, 0xf8,
	0x7e, 0xfa, 0xe1, 0xe3, 0x16, 0x77, 0x5f, 0x82, 0xbb, 0xba, 0xc0, 0x92, 0x9b, 0x70, 0xed, 0xf3,
	0xe8, 0x2c, 0x12, 0x2f, 0x22, 0x5b, 0xe4, 0x16, 0x50, 0x30, 0x62, 0xd3, 0xc5, 0x8c, 0xc6, 0x39,
	0x81, 0x43, 0x36, 0xe1, 0xc6, 0x40, 0x44, 0xde, 0x22, 0x8e, 0x59, 0xa4, 0x72, 0xb2, 0x22, 0xb9,
	0x01, 0xe4, 0xa9, 0xee, 0xd9, 0x1c, 0x5e, 0xda, 0xfd, 0x08, 0xba, 0x2b, 0xa3, 0x08, 0x33, 0xfe,
	0x44, 0x58, 0xa0, 0x5b, 0x20, 0x00, 0x55, 0x4c, 0xf2, 0x1c, 0x6f, 0xbb, 0x0b, 0x2d, 0x7b, 0x40,
	0x62, 0x1a, 0x07, 0xa3, 0xc1, 0x4f, 0xf6, 0x87, 0x87, 0x87, 0x87, 0x6e, 0x01, 0x2f, 0x7e, 0x34,
	0xfc, 0xf5, 0xd1, 0x17, 0x07, 0x5f, 0xba, 0xce, 0x83, 0x5b, 0xaf, 0xff, 0xbd, 0x55, 0x78, 0xf5,
	0x66, 0xcb, 0x79, 0xfd, 0x66, 0xcb, 0xf9, 0xd7, 0x9b, 0x2d, 0xe7, 0x77, 0x6f, 0xb7, 0x0a, 0xaf,
	0xdf, 0x6e, 0x15, 0xfe, 0xfe, 0x76, 0xab, 0xf0, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xd0, 0x3a,
	0x9f, 0xa8, 0x02, 0x14, 0x00, 0x00,
}

func (m *Bootstrap) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Bootstrap) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for k, _ := range m.Addresses {
			dAtA[i] = 0xa
			i++
			v := m.Addresses[k]
			mapSize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			i = encodeVarintRaft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRaft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRaft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	dAtA[i] = 0x10
	i++
	if m.Join {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Type))
	return i, nil
}

func (m *RaftDataStatus) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RaftDataStatus) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Address)))
	i += copy(dAtA[i:], m.Address)
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.BinVer))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.HardHash))
	dAtA[i] = 0x22
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.LogdbType)))
	i += copy(dAtA[i:], m.LogdbType)
	dAtA[i] = 0x2a
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Hostname)))
	i += copy(dAtA[i:], m.Hostname)
	dAtA[i] = 0x30
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.DeploymentId))
	dAtA[i] = 0x38
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.StepWorkerCount))
	dAtA[i] = 0x40
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.LogdbShardCount))
	dAtA[i] = 0x48
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.MaxSessionCount))
	dAtA[i] = 0x50
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.EntryBatchSize))
	return i, nil
}

func (m *State) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *State) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Term))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Vote))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Commit))
	return i, nil
}

func (m *Entry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

/*
func (m *Entry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Term))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Index))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Key))
	dAtA[i] = 0x28
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ClientID))
	dAtA[i] = 0x30
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.SeriesID))
	dAtA[i] = 0x38
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.RespondedTo))
	if m.Cmd != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Cmd)))
		i += copy(dAtA[i:], m.Cmd)
	}
	return i, nil
}*/

func (m *EntryBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *EntryBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRaft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Membership) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Membership) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ConfigChangeId))
	if len(m.Addresses) > 0 {
		for k, _ := range m.Addresses {
			dAtA[i] = 0x12
			i++
			v := m.Addresses[k]
			mapSize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			i = encodeVarintRaft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRaft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRaft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Removed) > 0 {
		for k, _ := range m.Removed {
			dAtA[i] = 0x1a
			i++
			v := m.Removed[k]
			mapSize := 1 + sovRaft(uint64(k)) + 1 + 1
			i = encodeVarintRaft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRaft(dAtA, i, uint64(k))
			dAtA[i] = 0x10
			i++
			if v {
				dAtA[i] = 1
			} else {
				dAtA[i] = 0
			}
			i++
		}
	}
	if len(m.Observers) > 0 {
		for k, _ := range m.Observers {
			dAtA[i] = 0x22
			i++
			v := m.Observers[k]
			mapSize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			i = encodeVarintRaft(dAtA, i, uint64(mapSize))
			dAtA[i] = 0x8
			i++
			i = encodeVarintRaft(dAtA, i, uint64(k))
			dAtA[i] = 0x12
			i++
			i = encodeVarintRaft(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *SnapshotFile) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotFile) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Filepath)))
	i += copy(dAtA[i:], m.Filepath)
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileSize))
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileId))
	if m.Metadata != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Metadata)))
		i += copy(dAtA[i:], m.Metadata)
	}
	return i, nil
}

func (m *Snapshot) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Snapshot) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x12
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Filepath)))
	i += copy(dAtA[i:], m.Filepath)
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileSize))
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Index))
	dAtA[i] = 0x28
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Term))
	dAtA[i] = 0x32
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Membership.Size()))
	n1, err := m.Membership.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n1
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintRaft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Checksum != nil {
		dAtA[i] = 0x42
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Checksum)))
		i += copy(dAtA[i:], m.Checksum)
	}
	dAtA[i] = 0x48
	i++
	if m.Dummy {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x50
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ClusterId))
	dAtA[i] = 0x58
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x60
	i++
	if m.Imported {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x68
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.OnDiskIndex))
	return i, nil
}

func (m *Message) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Message) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.To))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.From))
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ClusterId))
	dAtA[i] = 0x28
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Term))
	dAtA[i] = 0x30
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.LogTerm))
	dAtA[i] = 0x38
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.LogIndex))
	dAtA[i] = 0x40
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Commit))
	dAtA[i] = 0x48
	i++
	if m.Reject {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x50
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Hint))
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			dAtA[i] = 0x5a
			i++
			i = encodeVarintRaft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x62
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Snapshot.Size()))
	n2, err := m.Snapshot.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n2
	dAtA[i] = 0x68
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.HintHigh))
	return i, nil
}

func (m *ConfigChange) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ConfigChange) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ConfigChangeId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Type))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.NodeID))
	dAtA[i] = 0x22
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Address)))
	i += copy(dAtA[i:], m.Address)
	dAtA[i] = 0x28
	i++
	if m.Initialize {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	return i, nil
}

func (m *SnapshotHeader) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotHeader) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.SessionSize))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.DataStoreSize))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.UnreliableTime))
	dAtA[i] = 0x22
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.GitVersion)))
	i += copy(dAtA[i:], m.GitVersion)
	if m.HeaderChecksum != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.HeaderChecksum)))
		i += copy(dAtA[i:], m.HeaderChecksum)
	}
	if m.PayloadChecksum != nil {
		dAtA[i] = 0x32
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.PayloadChecksum)))
		i += copy(dAtA[i:], m.PayloadChecksum)
	}
	dAtA[i] = 0x38
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ChecksumType))
	dAtA[i] = 0x40
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Version))
	dAtA[i] = 0x48
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.CompressionType))
	return i, nil
}

func (m *Response) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Response) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *MessageBatch) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MessageBatch) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, msg := range m.Requests {
			dAtA[i] = 0xa
			i++
			i = encodeVarintRaft(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.DeploymentId))
	dAtA[i] = 0x1a
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.SourceAddress)))
	i += copy(dAtA[i:], m.SourceAddress)
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.BinVer))
	return i, nil
}

func (m *SnapshotChunk) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SnapshotChunk) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0x8
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ClusterId))
	dAtA[i] = 0x10
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.NodeId))
	dAtA[i] = 0x18
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.From))
	dAtA[i] = 0x20
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ChunkId))
	dAtA[i] = 0x28
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ChunkSize))
	dAtA[i] = 0x30
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.ChunkCount))
	if m.Data != nil {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintRaft(dAtA, i, uint64(len(m.Data)))
		i += copy(dAtA[i:], m.Data)
	}
	dAtA[i] = 0x40
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Index))
	dAtA[i] = 0x48
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Term))
	dAtA[i] = 0x52
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.Membership.Size()))
	n3, err := m.Membership.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n3
	dAtA[i] = 0x62
	i++
	i = encodeVarintRaft(dAtA, i, uint64(len(m.Filepath)))
	i += copy(dAtA[i:], m.Filepath)
	dAtA[i] = 0x68
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileSize))
	dAtA[i] = 0x70
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.DeploymentId))
	dAtA[i] = 0x78
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileChunkId))
	dAtA[i] = 0x80
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileChunkCount))
	dAtA[i] = 0x88
	i++
	dAtA[i] = 0x1
	i++
	if m.HasFileInfo {
		dAtA[i] = 1
	} else {
		dAtA[i] = 0
	}
	i++
	dAtA[i] = 0x92
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.FileInfo.Size()))
	n4, err := m.FileInfo.MarshalTo(dAtA[i:])
	if err != nil {
		return 0, err
	}
	i += n4
	dAtA[i] = 0x98
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.BinVer))
	dAtA[i] = 0xa0
	i++
	dAtA[i] = 0x1
	i++
	i = encodeVarintRaft(dAtA, i, uint64(m.OnDiskIndex))
	return i, nil
}

func encodeVarintRaft(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Bootstrap) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Addresses) > 0 {
		for k, v := range m.Addresses {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRaft(uint64(mapEntrySize))
		}
	}
	n += 2
	n += 1 + sovRaft(uint64(m.Type))
	return n
}

func (m *RaftDataStatus) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Address)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.BinVer))
	n += 1 + sovRaft(uint64(m.HardHash))
	l = len(m.LogdbType)
	n += 1 + l + sovRaft(uint64(l))
	l = len(m.Hostname)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.DeploymentId))
	n += 1 + sovRaft(uint64(m.StepWorkerCount))
	n += 1 + sovRaft(uint64(m.LogdbShardCount))
	n += 1 + sovRaft(uint64(m.MaxSessionCount))
	n += 1 + sovRaft(uint64(m.EntryBatchSize))
	return n
}

func (m *State) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.Term))
	n += 1 + sovRaft(uint64(m.Vote))
	n += 1 + sovRaft(uint64(m.Commit))
	return n
}

/*
func (m *Entry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.Term))
	n += 1 + sovRaft(uint64(m.Index))
	n += 1 + sovRaft(uint64(m.Type))
	n += 1 + sovRaft(uint64(m.Key))
	n += 1 + sovRaft(uint64(m.ClientID))
	n += 1 + sovRaft(uint64(m.SeriesID))
	n += 1 + sovRaft(uint64(m.RespondedTo))
	if m.Cmd != nil {
		l = len(m.Cmd)
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}*/

func (m *EntryBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	return n
}

func (m *Membership) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.ConfigChangeId))
	if len(m.Addresses) > 0 {
		for k, v := range m.Addresses {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRaft(uint64(mapEntrySize))
		}
	}
	if len(m.Removed) > 0 {
		for k, v := range m.Removed {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRaft(uint64(k)) + 1 + 1
			n += mapEntrySize + 1 + sovRaft(uint64(mapEntrySize))
		}
	}
	if len(m.Observers) > 0 {
		for k, v := range m.Observers {
			_ = k
			_ = v
			mapEntrySize := 1 + sovRaft(uint64(k)) + 1 + len(v) + sovRaft(uint64(len(v)))
			n += mapEntrySize + 1 + sovRaft(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *SnapshotFile) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filepath)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.FileSize))
	n += 1 + sovRaft(uint64(m.FileId))
	if m.Metadata != nil {
		l = len(m.Metadata)
		n += 1 + l + sovRaft(uint64(l))
	}
	return n
}

func (m *Snapshot) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Filepath)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.FileSize))
	n += 1 + sovRaft(uint64(m.Index))
	n += 1 + sovRaft(uint64(m.Term))
	l = m.Membership.Size()
	n += 1 + l + sovRaft(uint64(l))
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	if m.Checksum != nil {
		l = len(m.Checksum)
		n += 1 + l + sovRaft(uint64(l))
	}
	n += 2
	n += 1 + sovRaft(uint64(m.ClusterId))
	n += 1 + sovRaft(uint64(m.Type))
	n += 2
	n += 1 + sovRaft(uint64(m.OnDiskIndex))
	return n
}

func (m *Message) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.Type))
	n += 1 + sovRaft(uint64(m.To))
	n += 1 + sovRaft(uint64(m.From))
	n += 1 + sovRaft(uint64(m.ClusterId))
	n += 1 + sovRaft(uint64(m.Term))
	n += 1 + sovRaft(uint64(m.LogTerm))
	n += 1 + sovRaft(uint64(m.LogIndex))
	n += 1 + sovRaft(uint64(m.Commit))
	n += 2
	n += 1 + sovRaft(uint64(m.Hint))
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	l = m.Snapshot.Size()
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.HintHigh))
	return n
}

func (m *ConfigChange) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.ConfigChangeId))
	n += 1 + sovRaft(uint64(m.Type))
	n += 1 + sovRaft(uint64(m.NodeID))
	l = len(m.Address)
	n += 1 + l + sovRaft(uint64(l))
	n += 2
	return n
}

func (m *SnapshotHeader) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.SessionSize))
	n += 1 + sovRaft(uint64(m.DataStoreSize))
	n += 1 + sovRaft(uint64(m.UnreliableTime))
	l = len(m.GitVersion)
	n += 1 + l + sovRaft(uint64(l))
	if m.HeaderChecksum != nil {
		l = len(m.HeaderChecksum)
		n += 1 + l + sovRaft(uint64(l))
	}
	if m.PayloadChecksum != nil {
		l = len(m.PayloadChecksum)
		n += 1 + l + sovRaft(uint64(l))
	}
	n += 1 + sovRaft(uint64(m.ChecksumType))
	n += 1 + sovRaft(uint64(m.Version))
	n += 1 + sovRaft(uint64(m.CompressionType))
	return n
}

func (m *Response) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *MessageBatch) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Requests) > 0 {
		for _, e := range m.Requests {
			l = e.Size()
			n += 1 + l + sovRaft(uint64(l))
		}
	}
	n += 1 + sovRaft(uint64(m.DeploymentId))
	l = len(m.SourceAddress)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.BinVer))
	return n
}

func (m *SnapshotChunk) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	n += 1 + sovRaft(uint64(m.ClusterId))
	n += 1 + sovRaft(uint64(m.NodeId))
	n += 1 + sovRaft(uint64(m.From))
	n += 1 + sovRaft(uint64(m.ChunkId))
	n += 1 + sovRaft(uint64(m.ChunkSize))
	n += 1 + sovRaft(uint64(m.ChunkCount))
	if m.Data != nil {
		l = len(m.Data)
		n += 1 + l + sovRaft(uint64(l))
	}
	n += 1 + sovRaft(uint64(m.Index))
	n += 1 + sovRaft(uint64(m.Term))
	l = m.Membership.Size()
	n += 1 + l + sovRaft(uint64(l))
	l = len(m.Filepath)
	n += 1 + l + sovRaft(uint64(l))
	n += 1 + sovRaft(uint64(m.FileSize))
	n += 1 + sovRaft(uint64(m.DeploymentId))
	n += 1 + sovRaft(uint64(m.FileChunkId))
	n += 2 + sovRaft(uint64(m.FileChunkCount))
	n += 3
	l = m.FileInfo.Size()
	n += 2 + l + sovRaft(uint64(l))
	n += 2 + sovRaft(uint64(m.BinVer))
	n += 2 + sovRaft(uint64(m.OnDiskIndex))
	return n
}

func sovRaft(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozRaft(x uint64) (n int) {
	return sovRaft(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Bootstrap) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Bootstrap: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Bootstrap: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addresses == nil {
				m.Addresses = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRaft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRaft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRaft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRaft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Addresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Join", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Join = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StateMachineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RaftDataStatus) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RaftDataStatus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RaftDataStatus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinVer", wireType)
			}
			m.BinVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BinVer |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HardHash", wireType)
			}
			m.HardHash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HardHash |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogdbType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LogdbType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hostname", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Hostname = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			m.DeploymentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StepWorkerCount", wireType)
			}
			m.StepWorkerCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.StepWorkerCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogdbShardCount", wireType)
			}
			m.LogdbShardCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogdbShardCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MaxSessionCount", wireType)
			}
			m.MaxSessionCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MaxSessionCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryBatchSize", wireType)
			}
			m.EntryBatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.EntryBatchSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *State) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: State: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: State: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Vote", wireType)
			}
			m.Vote = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Vote |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

/*
func (m *Entry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= EntryType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Key", wireType)
			}
			m.Key = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Key |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientID", wireType)
			}
			m.ClientID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SeriesID", wireType)
			}
			m.SeriesID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SeriesID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RespondedTo", wireType)
			}
			m.RespondedTo = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.RespondedTo |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cmd", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Cmd = append(m.Cmd[:0], dAtA[iNdEx:postIndex]...)
			if m.Cmd == nil {
				m.Cmd = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}*/

func (m *EntryBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EntryBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EntryBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Membership) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Membership: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Membership: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChangeId", wireType)
			}
			m.ConfigChangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigChangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addresses", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Addresses == nil {
				m.Addresses = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRaft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRaft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRaft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRaft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Addresses[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Removed", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Removed == nil {
				m.Removed = make(map[uint64]bool)
			}
			var mapkey uint64
			var mapvalue bool
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var mapvaluetemp int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapvaluetemp |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					mapvalue = bool(mapvaluetemp != 0)
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRaft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRaft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Removed[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Observers", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Observers == nil {
				m.Observers = make(map[uint64]string)
			}
			var mapkey uint64
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowRaft
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthRaft
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthRaft
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipRaft(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthRaft
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Observers[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotFile) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotFile: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotFile: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileId", wireType)
			}
			m.FileId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Metadata", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Metadata = append(m.Metadata[:0], dAtA[iNdEx:postIndex]...)
			if m.Metadata == nil {
				m.Metadata = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Snapshot) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Snapshot: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Snapshot: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Membership", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Membership.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &SnapshotFile{})
			if err := m.Files[len(m.Files)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Checksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Checksum = append(m.Checksum[:0], dAtA[iNdEx:postIndex]...)
			if m.Checksum == nil {
				m.Checksum = []byte{}
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Dummy", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Dummy = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= StateMachineType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Imported", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Imported = bool(v != 0)
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDiskIndex", wireType)
			}
			m.OnDiskIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDiskIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

/*
func (m *Message) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Message: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Message: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= MessageType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			m.To = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.To |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogTerm", wireType)
			}
			m.LogTerm = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogTerm |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LogIndex", wireType)
			}
			m.LogIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.LogIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Commit", wireType)
			}
			m.Commit = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Commit |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reject", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Reject = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hint", wireType)
			}
			m.Hint = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hint |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snapshot", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Snapshot.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HintHigh", wireType)
			}
			m.HintHigh = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HintHigh |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}*/

func (m *ConfigChange) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ConfigChange: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ConfigChange: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ConfigChangeId", wireType)
			}
			m.ConfigChangeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ConfigChangeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			m.Type = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Type |= ConfigChangeType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeID", wireType)
			}
			m.NodeID = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeID |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Address", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Address = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initialize", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Initialize = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SnapshotHeader) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotHeader: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotHeader: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SessionSize", wireType)
			}
			m.SessionSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SessionSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DataStoreSize", wireType)
			}
			m.DataStoreSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DataStoreSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UnreliableTime", wireType)
			}
			m.UnreliableTime = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UnreliableTime |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GitVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GitVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field HeaderChecksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.HeaderChecksum = append(m.HeaderChecksum[:0], dAtA[iNdEx:postIndex]...)
			if m.HeaderChecksum == nil {
				m.HeaderChecksum = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PayloadChecksum", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PayloadChecksum = append(m.PayloadChecksum[:0], dAtA[iNdEx:postIndex]...)
			if m.PayloadChecksum == nil {
				m.PayloadChecksum = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChecksumType", wireType)
			}
			m.ChecksumType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChecksumType |= ChecksumType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			m.Version = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Version |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CompressionType", wireType)
			}
			m.CompressionType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.CompressionType |= CompressionType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Response) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Response: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Response: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}

/*
func (m *MessageBatch) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MessageBatch: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MessageBatch: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Requests", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Requests = append(m.Requests, Message{})
			if err := m.Requests[len(m.Requests)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			m.DeploymentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceAddress", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceAddress = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinVer", wireType)
			}
			m.BinVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BinVer |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}*/
func (m *SnapshotChunk) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SnapshotChunk: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SnapshotChunk: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterId", wireType)
			}
			m.ClusterId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClusterId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeId", wireType)
			}
			m.NodeId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NodeId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			m.From = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.From |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkId", wireType)
			}
			m.ChunkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkSize", wireType)
			}
			m.ChunkSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ChunkCount", wireType)
			}
			m.ChunkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ChunkCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Data = append(m.Data[:0], dAtA[iNdEx:postIndex]...)
			if m.Data == nil {
				m.Data = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Index |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Term", wireType)
			}
			m.Term = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Term |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Membership", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Membership.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filepath", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filepath = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileSize", wireType)
			}
			m.FileSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileSize |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 14:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeploymentId", wireType)
			}
			m.DeploymentId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeploymentId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileChunkId", wireType)
			}
			m.FileChunkId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileChunkId |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileChunkCount", wireType)
			}
			m.FileChunkCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.FileChunkCount |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasFileInfo", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasFileInfo = bool(v != 0)
		case 18:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileInfo", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthRaft
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthRaft
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.FileInfo.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 19:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BinVer", wireType)
			}
			m.BinVer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BinVer |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OnDiskIndex", wireType)
			}
			m.OnDiskIndex = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.OnDiskIndex |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipRaft(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthRaft
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipRaft(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowRaft
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowRaft
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthRaft
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthRaft
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowRaft
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipRaft(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthRaft
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthRaft = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowRaft   = fmt.Errorf("proto: integer overflow")
)
